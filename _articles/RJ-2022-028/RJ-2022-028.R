# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit RJ-2022-028.Rmd to modify this file

## ----setup, include=FALSE-----------------------------------------------------
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(ICvectorfields)
library(ggplot2)
library(ggnewscale)
library(metR)
library(png)


## ---- 1, fig.cap="The STIC algorithm: The input array in step one is a raster stack of images in which each image layer represents the phenomenon of interest in planar space at a different time instance. In step two, the input array is duplicated and based on a user specified time lag, layers are removed from the top of one array and the bottom of the other. In addition, a region of interest is defined in one of the duplicate arrays represented by the grey shaded region at the top of the prism on the left. In step four the rows are dimension reduced by averaging along one of the axes (either rows or columns). This produces a pair or row-averaged matrices and a pair of column-averaged matrices that are analyzed using cross-correlation to estimate orthogonal velocity vectors."----

# Importing a figure from an external source.
STIC <- readPNG("STICAlgorithm.png")

# plotting
par(mar = c(0,0,0,0))
plot(1:10,1:10, type = 'n', axes = F, ann = F)
rasterImage(STIC, xleft = 1, ybottom = 1, xright = 10, ytop = 10)



## ---- ftab1-------------------------------------------------------------------
func <- c("DispField", "DispFieldbb", "DispFieldST", "DispFieldSTbb", "DispFieldSTall", "DispFieldSTbball")
algo <- c("DIC", "DIC", "STIC", "STIC", "STIC+", "STIC+")
Images <- c("2", "2", "3+", "3+", "3+", "3+")
ROI <- c("grid", "bounding box", "grid", "bounding box", "grid", "bounding box")
Vels <- c("variable or not", "variable or not", "less variable", "less variable",
          "more variable", "more variable")

ftab1 <- data.frame(func, algo, Images, ROI, Vels)
colnames(ftab1) <- c("function", "algorithm", "images", "ROI", "velocities")


## ---- function-table, eval = knitr::is_html_output()--------------------------
#> knitr::kable(ftab1, format = "html", caption = "ICvectorfields functions, algorithms, and use contexts to facilitate decisions on which function is most applicable. ROI stands for region of interest, which is defined either using a grid or a bounding box, Velocities refers to whether the magnitudes of velocities in the vector field are presumed to be spatially variable or not.")


## ---- function-table-tex, eval = knitr::is_latex_output()---------------------
knitr::kable(ftab1, format = "latex", caption = "ICvectorfields functions, algorithms, and use contexts to facilitate decisions on which function is most applicable. ROI stands for region of interest, which is defined either using a grid or a bounding box, Velocities refers to whether the magnitudes of velocities in the vector field are presumed to be spatially variable or not.")


## ----echo=FALSE---------------------------------------------------------------
conflicted::conflict_prefer("layout", "graphics")


## ---- 2, fig.cap="Visualization of simulation data for six time steps. The initial condition at t0 is not shown. Green colours represent the highest concentrations. The populations in each quadrant move counterclockwise as time steps forward.", echo = TRUE----
# import simulated data
data(SimData, package = "ICvectorfields")

# convert to raster stack
SimStack <- ICvectorfields::RastStackData(SimData)

# confirming dimension
#dim(SimStack)

# plotting
layout(matrix(1:6, 2, 3, byrow = TRUE))
#layout.show(6)
terra::plot(SimStack[[1]], legend = FALSE, main = "t1")
terra::plot(SimStack[[2]], legend = FALSE, main = "t2")
terra::plot(SimStack[[3]], legend = FALSE, main = "t3")
terra::plot(SimStack[[4]], legend = FALSE, main = "t4")
terra::plot(SimStack[[5]], legend = FALSE, main = "t5")
terra::plot(SimStack[[6]], legend = FALSE, main = "t6")


## ---- DispField Call, echo = TRUE---------------------------------------------
# Estimating displacement of simulated data using the DispField function
VFdf1 <- DispField(SimStack[[1]], SimStack[[6]], factv1 = 101, facth1 = 101, 
                    restricted = TRUE)


## ---- DispField-output, eval = knitr::is_html_output()------------------------
#> knitr::kable(VFdf1[-c(3:6)], format = "html", caption = "ICvectorfields output from a call of the DispField function using simulated data. The table is a duplicate of the data table returned after calling the function except that columns 3 through 6 have been omitted so that the table fits within page width limits.")


## ---- DispField-output-tex, eval = knitr::is_latex_output()-------------------
knitr::kable(VFdf1[-c(3:6)], format = "latex", caption = "ICvectorfields output from a call of the DispField function using simulated data. The table is a duplicate of the data table returned after calling the function except that columns 3 through 6 have been omitted so that the table fits within page width limits.")


## ---- DispFieldST-output, echo = TRUE-----------------------------------------
# Estimating orthogonal velocity vectors of simulated data using the DispFieldST function
VFdf2 <- DispFieldST(SimStack, lag1 = 1, factv1 = 101, facth1 = 101, restricted = TRUE)


## ---- 3, fig.cap="Vector field for radial movement simulated using a convection-diffusion equation. The orthogonal velocity vectors are estimated using the DispFieldST function in the ICvectorfields package.", echo = TRUE----

SimVF <- ggplot() +
  xlim(c(-5, 5)) +
  ylim(c(-5, 5)) +
  geom_raster(data = SimData,
              aes(x = xcoord, y = ycoord, fill = t1)) +
  scale_fill_gradient(low = "white", high = "blue", na.value = NA) +
  new_scale("fill") +
  geom_raster(data = SimData,
              aes(x = xcoord, y = ycoord, fill = t6), alpha = 0.5) +
  scale_fill_gradient(low = "white", high = "red", na.value = NA) +
  geom_vector(data = VFdf2, 
              aes(x = centx, y = centy, 
                  mag = Mag(dispx, dispy), 
                  angle = Angle(dispx, dispy))) + 
  theme(panel.background = element_rect(fill = "white", color = "grey"),
        legend.key.size = unit(0.4, 'cm'))

SimVF


## ---- Pitfall, echo = TRUE----------------------------------------------------
# Estimating orthogonal velocity vectors of simulated data using the DispFieldST function
VFdf3 <- DispFieldST(SimStack, lag1 = 1, factv1 = 101, facth1 = 101, restricted = FALSE)


## ---- Pitfall-demo, eval = knitr::is_html_output()----------------------------
#> knitr::kable(VFdf3[-c(3:6)], format = "html", caption = "Output from a call of the DispFieldST function using simulated data. This call is meant to demonstrate a potential pitfall in using the cross-correlation approach because when restricted = FALSE, the algorithm finds positive cross-correlations that are not caused by movement. The table is a duplicate of the data table returned after calling the function except that columns 3 through 6 have been omitted so that the table fits within page width limits.")


## ---- Pitfall-demo-tex, eval = knitr::is_latex_output()-----------------------
knitr::kable(VFdf3[-c(3:6)], format = "latex", caption = "Output from a call of the DispFieldST function using simulated data. This call is meant to demonstrate a potential pitfall in using the cross-correlation approach because when restricted = FALSE, the algorithm finds positive cross-correlations that are not caused by movement. The table is a duplicate of the data table returned after calling the function except that columns 3 through 6 have been omitted so that the table fits within page width limits.")


## ---- 4, fig.cap="The first five years of the larch budmoth defoliation data included in the ncf package. Green colours represent the highest level of defoliation. Defoliation intensity moves from the southwest to the northeast but not along a straight trajectory between the southwest and northeast corners.", echo = TRUE----
# import larch budmoth data
data(lbm, package = "ncf")

# convert to raster stack
LBMStack <- ICvectorfields::RastStackData(lbm)

# confirming dimension
#dim(LBMStack)

# visualizing
layout(matrix(1:6, 2, 3, byrow = TRUE))
#layout.show(6)
terra::plot(LBMStack[[1]], legend = FALSE, main = "1961")
terra::plot(LBMStack[[2]], legend = FALSE, main = "1962")
terra::plot(LBMStack[[3]], legend = FALSE, main = "1963")
terra::plot(LBMStack[[4]], legend = FALSE, main = "1964")
terra::plot(LBMStack[[5]], legend = FALSE, main = "1965")


## ---- lbm-vf, echo = TRUE-----------------------------------------------------
# calculating velocity field for larch budmoth
VFdf3 <- DispFieldSTall(LBMStack[[1:23]], lagmax = 3, factv1 = 3, facth1 = 3, restricted = FALSE)


## ---- 5, fig.cap="Vector field for Larch Budmoth persistent movement. The orthogonal velocity vectors are estimated using the DispFieldSTall function in the ICvectorfields package. Blue colours show the locations and intensities of defoliation in 1962 and red colours show the locations and intensities of defoliation in 1964. Vectors have their own scale that is distinct from the scale of the map. The figure shows that velocities point predominantly to the north on the southwest corner of the map and predominantly to the east on the northeast corner of the map. In addition, outbreaks appear to slow down as they turn the corner from southwest to northeast."----
LBMVF1 <- ggplot() +
  geom_tile(data = lbm,
              aes(x = x, y = y, 
                  fill = X1962)) +
  scale_fill_gradient(low = "white", high = "blue", na.value = NA) +
  new_scale("fill") +
  geom_tile(data = lbm,
              aes(x = x, y = y, fill = X1964), alpha = 0.5) +
  scale_fill_gradient(low = "white", high = "red", na.value = NA) +
  geom_vector(data = VFdf3, 
              aes(x = centx, y = centy, 
                  mag = Mag(dispx, dispy), 
                  angle = Angle(dispx, dispy))) + 
  theme(panel.background = element_rect(fill = "white", color = "grey"),
        legend.key.size = unit(0.4, 'cm'))
LBMVF1


## ---- speed-calc, echo = TRUE-------------------------------------------------
# calculating average speed of population movement
VFdf3$speed <- sqrt((VFdf3$dispx^2) + VFdf3$dispy^2)

# sub-setting to remove locations where speed is zero
VFdf4 <- subset(VFdf3, speed > 0)

# computing mean, standard deviation and dimension of data frame
# to obtain sample size
mean(VFdf4$speed)
#sd(VFdf4$speed)
#dim(VFdf4)

# upper and lower Wald-type 95 percent confidence interval on average speed
mean(VFdf4$speed)/1000 + qt(0.975, dim(VFdf4)[1] - 1)*sd(VFdf4$speed)/1000/sqrt(dim(VFdf4)[1] - 1)
mean(VFdf4$speed)/1000 + qt(0.025, dim(VFdf4)[1] - 1)*sd(VFdf4$speed)/1000/sqrt(dim(VFdf4)[1] - 1)

