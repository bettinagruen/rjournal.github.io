# Generated by `rjournal_article()` using `knitr::purl()`: do not edit by hand
# Please edit EAT.Rmd to modify this file

## ----setup, include = FALSE---------------------------------------------------
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, fig.align = "center")
library(eat)
library(kableExtra)
library(dplyr)


## ----fun-tab, eval = knitr::is_html_output(), layout = "l-body-outset"--------
#> Functions <-
#>   c("`EAT`",
#>     "`bestEAT`",
#>     "`efficiencyEAT`",
#>     "`efficiencyJitter`",
#>     "`efficiencyDensity`",
#>     "`plotEAT`",
#>     "`frontier`",
#>     "`predict`",
#>     "`rankingEAT`",
#>     "`RFEAT`",
#>     "`bestRFEAT`",
#>     "`efficiencyRFEAT`",
#>     "`plotRFEAT`",
#>     "`predict`",
#>     "`rankingRFEAT`",
#>     "`efficiencyCEAT`",
#>     "`Y1.sim`",
#>     "`X2Y2.sim`"
#>     )
#> 
#> Description <-
#>   c('For `EAT`. It generates a pruned Efficiency Analysis Trees model and returns an `EAT` object.',
#>     'For `EAT`. It computes the root mean squared error (RMSE) for a set of Efficiency Analysis Trees models made up of a set of user-entered hyperparameters. These models are fitted with a training sample and evaluated with a test sample.',
#>     'For `EAT`. It computes the efficiency scores of a set of DMUs through a Efficiency Analysis Trees model and returns a `data.frame`. The FDH scores can also be computed. Alternative mathematical programming models for calculating the efficiency scores are: `"BCC.OUT"` (the output-oriented BCC radial model), `"BCC.INP"` (the input-oriented BCC radial model), `"DDF"` (the directional distance function), `"RSL.OUT"` (the output-oriented Russell model), `"RSL.INP"` (the input-oriented Russell model), `"WAM.MIP"` (the weighted additive model with Measure of Inefficiency Proportion) and `"WAM.RAM"` (the weighted additive model with Range Adjusted Measure of Inefficiency).',
#>     'For `EAT`. It returns a jitter plot (from `ggplot2`) that represents the dispersion of the efficiency scores of the set of DMUs in the leaf nodes of an Efficiency Analysis Trees model. Mean and standard deviation of scores are shown.',
#>     'It returns a density plot (from `ggplot2`) to compare the distribution of efficiency scores between two given models (`"EAT"`, `"FDH"`, `"CEAT"`, `"DEA"` and `"RFEAT"` are available).',
#>     'For `EAT`. It returns a plot of the tree-structure (from `ggparty` and `partykit`) of an Efficiency Analysis Trees model.',
#>     'For `EAT`. It returns a plot (from `ggplot2`) of the estimated production function obtained by an Efficiency Analysis Trees model in a two-dimensional scenario (1 input and 1 output). Optionally, the FDH frontier can be plotted.',
#>     'For `EAT`. Generic function to predict the expected output by an `EAT` object. The result is a `data.frame` with the the predicted values.',
#>     'For `EAT`. It returns a `data.frame` with the scores of variable importance obtained by an Efficiency Analysis Trees model and optionally a barplot representing the variable importance.',
#>     'For `RFEAT`. It generates a Random Forest for Efficiency Analysis Trees model and returns an `RFEAT` object.',
#>     'For `RFEAT`. It computes the root mean squared error (RMSE) for a set of Random Forest for Efficiency Analysis Trees models made up of a set of user-entered hyperparameters. These models are fitted with a training sample and evaluated with a test sample.',
#>     'For `RFEAT`. It computes the efficiency scores of a set of DMUs through a Random Forest for Efficiency Analysis Trees model and returns a `data.frame`. The FDH scores can also be computed. Only the output-oriented BCC radial model is available.',
#>     'For `RFEAT`. It returns a line plot (from `ggplot2`) with the Out-of-Bag (OOB) error for a random forest consisting of k trees.',
#>     'For `RFEAT`. Generic function to predict the expected output by an `RFEAT` object. The result is a `data.frame` with the predicted values.',
#>     'For `RFEAT`. It returns a `data.frame` with the scores of variable importance obtained by a Random Forest for Efficiency Analysis Trees model and optionally a barplot representing the variable importance.',
#>     'For `CEAT`. It computes the efficiency scores of a set of DMUs through a Convexified Efficiency Analysis Trees model and returns a `data.frame`. The DEA scores can also be computed. Alternative mathematical programming models for calculating the efficiency scores are: `"BCC.OUT"` (the output-oriented BCC radial model), `"BCC.INP"` (the input-oriented BCC radial model), `"DDF"` (the directional distance function), `"RSL.OUT"` (the output-oriented Russell model), `"RSL.INP"` (the input-oriented Russell model), `"WAM.MIP"` (the weighted additive model with Measure of Inefficiency Proportion) and `"WAM.RAM"` (the weighted additive model with Range Adjusted Measure of Inefficiency).',
#>     'Simulation function. It returns a `data.frame` with simulated data in a single output scenario (1, 3, 6, 9, 12 and 15 inputs can be generated).',
#>     'Simulation function. It returns a `data.frame` with simulated data in a scenario with 2 inputs and 2 outputs.'
#>     )
#> 
#> fun.tab <- cbind(Functions, Description)
#> 
#> fun.tab %>%
#>   knitr::kable(format = "html", caption = "eat package functions") %>%
#>   row_spec(01, align = "justify") %>%
#>   row_spec(02, align = "justify") %>%
#>   row_spec(03, align = "justify") %>%
#>   row_spec(04, align = "justify") %>%
#>   row_spec(05, align = "justify") %>%
#>   row_spec(06, align = "justify") %>%
#>   row_spec(07, align = "justify") %>%
#>   row_spec(08, align = "justify") %>%
#>   row_spec(09, align = "justify") %>%
#>   row_spec(10, align = "justify") %>%
#>   row_spec(11, align = "justify") %>%
#>   row_spec(12, align = "justify") %>%
#>   row_spec(13, align = "justify") %>%
#>   row_spec(14, align = "justify") %>%
#>   row_spec(15, align = "justify") %>%
#>   row_spec(16, align = "justify") %>%
#>   row_spec(17, align = "justify") %>%
#>   row_spec(18, align = "justify")


## ----alg-one, out.width = "100%", out.height = "30%", eval = knitr::is_html_output()----
#> knitr::include_graphics("algorithm1.png")


## ----library, echo = TRUE, eval = TRUE----------------------------------------
# We load the library
library("eat")

# We load the data
data("PISAindex")


## ----newdata, echo = TRUE, eval = TRUE----------------------------------------
# Inputs (5): PR, PFC, I, AAE, GDP_PPP
# Outputs (3): S_PISA, R_PISA, M_PISA
PISAindex <- PISAindex[, c(3, 4, 5, 14, 15, 16, 17, 18)]

head(PISAindex)


## ----summary-PISAindex--------------------------------------------------------
summary_table <- PISAindex %>%
  summarise(across(where(is.numeric), list(mean = mean, 
                                           sd = sd, 
                                           min = min, 
                                           median = median, 
                                           max = max), 
                   na.rm = TRUE,
                   .names = "{.col}.{.fn}")) %>%
  tidyr::pivot_longer(cols = everything(),
               names_sep = "\\.",
               names_to  = c("variable", ".value"))

type <- c(rep("output", 3), rep("input", 5))

summary_table <- cbind(summary_table[, 1], type, summary_table[, 2:6]) %>%
  mutate_if(is.numeric, round, 2)


## ----descr-html, eval = knitr::is_html_output(), layout = "l-body-outset"-----
#> knitr::kable(summary_table, format = "markdown", caption = "Descriptive statistics (averages, standard deviations, minimum, median and maximum) of input–output.")


## ----descr-lat, eval = knitr::is_latex_output()-------------------------------
knitr::kable(summary_table, format = "latex", caption = "Descriptive statistics (averages, standard deviations, minimum, median and maximum) of input–output.") %>% 
  kableExtra::kable_styling(font_size = 7)


## ----seed, echo = TRUE, eval = TRUE-------------------------------------------
# We set the seed
set.seed(100)


## ----EAT.function, echo = TRUE, eval = FALSE----------------------------------
#> EAT(
#>   data, x, y,
#>   numStop = 5,
#>   fold = 5,
#>   max.depth = NULL,
#>   max.leaves = NULL,
#>   na.rm = TRUE
#> )


## ----ex1, echo = TRUE, eval = TRUE--------------------------------------------
modelEAT <- EAT(data = PISAindex, x = 4:8, y = 1:3)


## ----RFEAT.function, echo = TRUE, eval = FALSE--------------------------------
#> RFEAT(
#>   data, x, y,
#>   numStop = 5,
#>   m = 50,
#>   s_mtry = "BRM",
#>   na.rm = TRUE
#> )


## ----ex2, echo = TRUE, eval = TRUE--------------------------------------------
modelRFEAT <- RFEAT(data = PISAindex, x = 4:8, y = 1:3, m = 30)


## ----predict.function, echo = TRUE, eval = FALSE------------------------------
#> predict(
#>   object,
#>   newdata,
#>   x, ...
#> )


## ----ex3, echo = TRUE, eval = TRUE--------------------------------------------
predict(object = modelEAT, newdata = tail(PISAindex, 3), x = 4:8)


## ----ex4, echo = TRUE, eval = TRUE--------------------------------------------
predict(object = modelRFEAT, newdata = tail(PISAindex, 3), x = 4:8)


## ----ex5, echo = TRUE, eval = TRUE--------------------------------------------
new <- data.frame(AAE = c(61, 72), PR = c(76, 81), I = c(41, 55), GDP_PPP = c(19, 31),
                  PFC = c(67, 78))
                  
predict(object = modelEAT, newdata = new, x = 1:5)


## ----rankingEAT.function, echo = TRUE, eval = FALSE---------------------------
#> # Through Efficiency Analysis Trees
#> rankingEAT(
#>   object,
#>   barplot = TRUE,
#>   threshold = 70,
#>   digits = 2
#> )
#> 
#> # Through Random Forest for Efficiency Analysis Trees
#> rankingRFEAT(
#>   object,
#>   barplot = TRUE,
#>   digits = 2
#> )


## ----ex6,  fig.height = 3.5, fig.width = 5.5, fig.cap = "Barplot generated by applying `rankingEAT()` to the PISAindex database to determine the ranking of variable importance.", fig.align = "center", echo=TRUE----
rankingEAT(object = modelEAT)


## ----ex7,  fig.height = 3.5, fig.width = 5.5, fig.cap = "Barplot generated by applying `rankingRFEAT()` to the PISAindex database to determine the ranking of variable importance.", fig.align = "center", echo=TRUE----
rankingRFEAT(object = modelRFEAT)


## ----efficiency.functions, echo = TRUE, eval = FALSE--------------------------
#> # For Efficiency Analysis Trees
#> efficiencyEAT(
#>   data, x, y, object, scores_model, digits = 3,
#>   FDH = TRUE, print.table = FALSE, na.rm = TRUE
#> )
#> 
#> # For Random Forest for Efficiency Analysis Trees
#> efficiencyRFEAT(
#>   data, x, y, object, digits = 3,
#>   FDH = TRUE, print.table = FALSE, na.rm = TRUE
#> )
#> 
#> # For Convexified Efficiency Analysis Trees
#> efficiencyCEAT(
#>   data, x, y, object, scores_model, digits = 3,
#>   DEA = TRUE, print.table = FALSE, na.rm = TRUE
#> )


## ----ex8, echo = TRUE, eval = TRUE--------------------------------------------
scores <- efficiencyEAT(data = PISAindex, x = 4:8, y = 1:3, object = modelEAT, 
                        scores_model = "BCC.OUT", digits = 2, 
                        print.table = TRUE)

scores %>% sample_n(3)


## ----ex9, echo = TRUE, eval = TRUE--------------------------------------------
scores <- efficiencyCEAT(data = PISAindex, x = 4:8, y = 1:3, object = modelEAT, 
                         scores_model = "BCC.OUT", digits = 2,
                         print.table = TRUE)

scores %>% sample_n(3)


## ----ex10, echo = TRUE, eval = TRUE-------------------------------------------
scores <- efficiencyRFEAT(data = PISAindex, x = 4:8, y = 1:3, object = modelRFEAT, 
                          digits = 2, print.table = TRUE)

scores %>% sample_n(3)


## ----ex11, echo = TRUE, eval = TRUE-------------------------------------------
scores <- efficiencyEAT(data = PISAindex, x = 4:8, y = 1:3, object = modelEAT, 
                        scores_model = "BCC.INP", digits = 2,
                        print.table = TRUE)

scores %>% sample_n(3)


## ----ex12, echo = TRUE, eval = TRUE-------------------------------------------
scores <- efficiencyCEAT(data = PISAindex, x = 4:8, y = 1:3, object = modelEAT, 
                         scores_model = "BCC.INP", digits = 2, 
                         print.table = TRUE)

scores %>% sample_n(3)


## ----ex13, echo = TRUE, eval = FALSE------------------------------------------
#> scores <- efficiencyEAT(data = PISAindex, x = 4:8, y = 1:3, object = modelEAT,
#>                         scores_model = "RSL.OUT", digits = 2,
#>                         print.table = TRUE)
#> 
#> scores %>% sample_n(3)


## ----ex14, echo = TRUE, eval = TRUE-------------------------------------------
scores <- efficiencyCEAT(data = PISAindex, x = 4:8, y = 1:3, object = modelEAT, 
                         scores_model = "RSL.OUT", digits = 2, 
                         print.table = TRUE)

scores %>% sample_n(3)


## ----ex15, echo = TRUE, eval = TRUE-------------------------------------------
scores <- efficiencyEAT(data = PISAindex, x = 4:8, y = 1:3, object = modelEAT, 
                        scores_model = "RSL.INP", digits = 2, 
                        print.table = TRUE)

scores %>% sample_n(3)


## ----ex16, echo = TRUE, eval = TRUE-------------------------------------------
scores <- efficiencyCEAT(data = PISAindex, x = 4:8, y = 1:3, object = modelEAT, 
                         scores_model = "RSL.INP", digits = 2,
                         print.table = TRUE)

scores %>% sample_n(3)


## ----ex17, echo = TRUE, eval = TRUE-------------------------------------------
scores <- efficiencyEAT(data = PISAindex, x = 4:8, y = 1:3, object = modelEAT, 
                        scores_model = "DDF", digits = 2, 
                        print.table = TRUE)

scores %>% sample_n(3)


## ----ex18, echo = TRUE, eval = TRUE-------------------------------------------
scores <- efficiencyCEAT(data = PISAindex, x = 4:8, y = 1:3, object = modelEAT, 
                         scores_model = "DDF", digits = 2, 
                         print.table = TRUE)

scores %>% sample_n(3)


## ----ex19, echo = TRUE, eval = TRUE-------------------------------------------
scores <- efficiencyEAT(data = PISAindex, x = 4:8, y = 1:3, object = modelEAT, 
                        scores_model = "WAM.MIP", digits = 2,
                        print.table = TRUE)

scores %>% sample_n(3)


## ----ex20, echo = TRUE, eval = TRUE-------------------------------------------
scores <- efficiencyEAT(data = PISAindex, x = 4:8, y = 1:3, object = modelEAT,
                        scores_model = "WAM.RAM", digits = 2,
                        print.table = TRUE)

scores %>% sample_n(3)


## ----ex21, echo = TRUE, eval = TRUE-------------------------------------------
scores <- efficiencyCEAT(data = PISAindex, x = 4:8, y = 1:3, object = modelEAT,
                         scores_model = "WAM.MIP", digits = 2,
                         print.table = TRUE)

scores %>% sample_n(3)


## ----ex22, echo = TRUE, eval = TRUE-------------------------------------------
scores <- efficiencyCEAT(data = PISAindex, x = 4:8, y = 1:3, object = modelEAT,
                         scores_model = "WAM.RAM", digits = 2,
                         print.table = TRUE)

scores %>% sample_n(3)


## ----best.functions, echo = TRUE, eval = FALSE--------------------------------
#> # Hyperparameter tuning for Efficiency Analysis Trees
#> bestEAT(
#>   training, test, x, y,
#>   numStop = 5, fold = 5,
#>   max.depth = NULL,
#>   max.leaves = NULL,
#>   na.rm = TRUE
#>   )
#> 
#> # Hyperparameter tuning for Random Forest for Efficiency Analysis Trees
#> bestRFEAT(
#>   training, test, x, y,
#>   numStop = 5, m = 50,
#>   s_mtry = c("5", "BRM"),
#>   na.rm = TRUE
#>   )


## ----train_test, echo = TRUE, eval = TRUE-------------------------------------
n <- nrow(PISAindex)              # Observations in the dataset
selected <- sample(1:n, n * 0.7)  # Training indexes
training <- PISAindex[selected, ] # Training set
test <- PISAindex[- selected, ]   # Test set


## ----ex24, echo = TRUE, eval = TRUE-------------------------------------------
bestEAT(training = training, test = test, x = 4:8, y = 1:3, 
        numStop = c(3, 5, 7), fold = c(5, 7))


## ----ex25, echo = TRUE, eval = TRUE-------------------------------------------
bestEAT_model <- EAT(data = PISAindex, x = 4:8, y = 1:3, numStop = 5, fold = 5)


## ----ex26_prep, echo = TRUE, eval = TRUE--------------------------------------
modelEAT2 <- EAT(data = PISAindex, x = 7, y = 3)


## ----ex26_1, echo = TRUE, eval = TRUE-----------------------------------------
print(modelEAT2) # [node] y: [prediction] || R: error n(t): nº of DMUs


## ----ex26_2, echo = TRUE, eval = TRUE-----------------------------------------
# Primary & surrogate splits: Node i --> {SL, SR} || var --> {R: error, s: threshold}
summary(modelEAT2)


## ----jitter.function, echo = TRUE, eval = FALSE-------------------------------
#> efficiencyJitter(
#>   object,
#>   df_scores,
#>   scores_model,
#>   upb = NULL,
#>   lwb = NULL
#> )


## ----ex27_prep, echo = TRUE, eval = TRUE--------------------------------------
scores <- efficiencyEAT(data = PISAindex, x = 7, y = 3, object = modelEAT2, 
                        scores_model = "BCC.OUT", digits = 2, 
                        print.table = FALSE)


## ----ex27,  fig.height = 4, fig.width = 6.5, fig.cap = "Jitter plot generated by 'efficiencyJitter()' to show how the countries are grouped inside three particular leaf nodes.", fig.align="center"----
efficiencyJitter(object = modelEAT2, df_scores = scores$EAT_BCC_OUT, 
                 scores_model = "BCC.OUT", lwb = 1.2)


## ----density.function, echo = TRUE, eval = FALSE------------------------------
#> efficiencyDensity(
#>   df_scores,
#>   model = c("EAT", "FDH")
#> )


## ----ex28,  fig.height = 4, fig.width = 6, fig.cap = "Density plot generated by 'efficiencyDensity()' to show the difference between the score obtained by EAT and FDH.", fig.align="center"----
efficiencyDensity(df_scores = scores, model = c("EAT", "FDH"))


## ----frontier.function, echo = TRUE, eval = FALSE-----------------------------
#> frontier(
#>   object, FDH = TRUE,
#>   observed.data = TRUE,
#>   observed.color = "black",
#>   pch = 19,vsize = 1,
#>   rwn = FALSE,
#>   max.overlaps = 10
#> )


## ----ex29_prep, echo = TRUE, eval = TRUE--------------------------------------
simulated <- Y1.sim(N = 50, nX = 1)
modelEAT3 <- EAT(data = simulated, x = 1, y = 2)


## ----ex29,  fig.height = 4, fig.width = 6, fig.cap = "Plot of productions functions corresponding to the EAT and the FDH estimator when 'frontier()' is applied.", fig.align="center"----
frontier(object = modelEAT3, FDH = TRUE, observed.data = TRUE, rwn = TRUE)


## ----plotEAT.function, echo = TRUE, eval = FALSE------------------------------
#> plotEAT(
#>   object
#> )


## ----ex30,  fig.height = 6.5, fig.width = 5.5, fig.cap = "Plot of the tree structure obtained through an EAT model with the parameter max.depth defined as 4.", fig.align = "center"----
NumStopModel <- EAT(data = PISAindex, x = 4:8, y = 1:3, max.depth = 4)
plotEAT(object = NumStopModel)


## ----plotRFEAT.function, echo = TRUE, eval = FALSE----------------------------
#> plotRFEAT(
#>   object
#> )


## ----ex31,  fig.height = 3.5, fig.width = 5.5, fig.cap = "Plot of the OOB error corresponding to 30 different RFEAT where k represents the number of trees belonging to each RF.", fig.align = "center"----
plotRFEAT(modelRFEAT)

