# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit RJ-2023-006.Rmd to modify this file

## ----setup, include=FALSE-----------------------------------------------------
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
# library(plotly)
library(xtable)
library(kableExtra)
options(xtable.include.rownames=FALSE, xtable.comment=FALSE)

# Dummy table function
dt = function(label, caption = NULL) {
        print(xtable(setNames(data.frame(x=numeric()), " "),
              caption     = caption,
              label       = paste0("tab:", label)), 
              hline.after = NULL,
              booktabs    = FALSE,
              size        = "\\fontsize{0.1pt}{0.1pt}\\selectfont")
     }


## ----fig1, echo = FALSE, eval = knitr::is_html_output(), warning = F, out.width = "100%", out.height = "30%"----
#> temp.df  = data.frame(image="![](figure1.png)")
#> temp.mat = as.matrix(temp.df)
#> colnames(temp.mat) = NULL
#> knitr::kable(temp.mat, caption="This package provides algorithms for merging two databases *A* and *B* where two variables of interest, *Y* and *Z*, are never jointly observed: the final result is a unique and synthetic database where *Y* and *Z* are fully completed.")
#> 


## ----code1, echo = TRUE, eval = FALSE-----------------------------------------
#> install.packages("OTrecod")
#> 


## ----tab2, eval = knitr::is_html_output(), layout = "l-body-outset"-----------
#> dat2 = rbind(c("Pre-process functions", ""),
#>              c("`merge_dbs`"           , "Harmonization of the data sources"),
#>              c("`select_pred`"         , "Selection of matching variables"),
#>              c("Functions of data fusion", ""),
#>              c("`OT_outcome`"          , "Data fusion with OT theory using the OUTCOME or R-OUTCOME algorithms."),
#>              c("`OT_joint`"            , "Data fusion with OT theory using the JOINT or R-JOINT algorithms."),
#>              c("Post-process function", ""),
#>              c("`verif_OT`"            , "Quality assessment of the data fusion"))
#> 
#> dat2 = as.data.frame(dat2)
#> # dat2[1,1] = kableExtra::cell_spec(dat2[1, 1], "html", bold = TRUE)
#> # dat2[4,1] = kableExtra::cell_spec(dat2[4, 1], "html", bold = TRUE)
#> # dat2[7,1] = kableExtra::cell_spec(dat2[7, 1], "html", bold = TRUE)
#> colnames(dat2) = c("R Function", "Description")
#> 
#> for(i in c(1,4,7)) {
#>   dat2[i, 1] <- kableExtra::cell_spec(dat2[i, 1], "html", bold = TRUE)
#> }
#> 
#> #for(i in c(2,3,5,6,8)) {
#> #  dat2[i, 1] <- kableExtra::cell_spec(dat2[i, 1], "html", italic = TRUE, color = "darkgray")
#> #}
#> 
#> kable(dat2, 'html', booktabs =TRUE, caption = "A brief description of the main functions of `OTrecod`", align = "ll", escape = FALSE) %>%
#> kableExtra::kable_styling(position = "center") %>%
#> column_spec(1, width = "12em") %>%
#> column_spec(2, width = "20em")
#> 


## ----tab3, eval = knitr::is_html_output(), layout = "l-body-outset"-----------
#> DB  = c(rep(1,3), rep(2,5))
#> Y   = c(rep("(600-800]",2), "[200-600]", rep(NA,5))
#> Z   = c(rep(NA,3),"G1","G3","G2","G4","G2")
#> X_1 = c("M","M","W","M","W","W","M","W")
#> X_2 = c("Yes", rep("No",3),"Yes", "No","Yes","Yes")
#> X_3 = c(50,32,31,47,43,23,22,47)
#> 
#> dat1 = data.frame(DB, Y, Z, X_1, X_2, X_3)
#> 
#> knitr::kable(dat1, format = "html", caption = "Example of expected structure for two databases 1 and 2 with three shared variables X<sub>1</sub>, X<sub>2</sub>, X<sub>3</sub>", align = "cccccc", table.attr = "style='width:40%;'", col.names = c("DB","Y","Z","X_1", "X_2", "X_3")) %>%
#> kableExtra::kable_styling(position = "center")


## ----code2, echo = TRUE, eval = TRUE------------------------------------------
library(OTrecod)
data(api29); data(api35)
summary(api29) #--------------------------------------------------


summary(api35) #--------------------------------------------------




## ----code3, echo = TRUE, eval = TRUE------------------------------------------
step1 = merge_dbs(DB1 = api29, DB2 = api35,
		    NAME_Y = "apicl_2000", NAME_Z = "apicl_1999",
		    row_ID1 = 1, row_ID2 = 1,  
		    ordinal_DB1 = c(2:3, 8:12), 
		    ordinal_DB2 = c(2:3, 8:12))




## ----code4, echo = TRUE, eval = TRUE------------------------------------------
summary(step1)
step1$REMOVE1   # List of removed variables because of type's problem


step1$REMOVE2   # List of removed factors because of levels' problem


levels(api29$mobility)  # Verification


levels(api29$mobility); levels(api35$mobility)


step1$REMAINING_VAR




## ----code5, echo = TRUE, eval = TRUE------------------------------------------
# For the dataset api29 --------------
step2a = select_pred(step1$DB_READY,
                     Y = "Y", Z = "Z", ID = 1, OUT = "Y",
                     quanti  = c(4,6), nominal = c(1,5,7), 
                     ordinal = c(2,3,8:12), thresh_cat = 0.50, 
                     thresh_num = 0.70, RF_SEED = 3011)

# For the dataset api35 --------------
step2b = select_pred(step1$DB_READY,
                     Y = "Y", Z = "Z", ID = 1, OUT = "Z",
                     quanti  = c(4,6), nominal = c(1,5,7), 
                     ordinal = c(2,3,8:12), thresh_cat = 0.50, 
                     thresh_num = 0.70, RF_SEED = 3011)




## ----code6, echo = TRUE, eval = TRUE------------------------------------------
### ASSOCIATIONS BETWEEN TARGET VARIABLES AND SHARED VARIABLES

## Results for the api29 dataset -----

step2a$cor_OUTC_num   # Y versus numeric or ordinal predictors


step2a$vcrm_OUTC_cat  # Y versus nominal or ordinal predictors



## Results for the api35 dataset -----

step2b$cor_OUTC_num   # Z versus numeric or ordinal predictors


step2b$vcrm_OUTC_cat  # Z versus nominal or ordinal predictors




## ----code7, echo = TRUE, eval = TRUE------------------------------------------
### DETECTION OF REDUNDANT PREDICTORS

## Results for the api29 dataset -----

## Results of the Farrar-Glauber test 
step2a$FG_test       


## Identity of the redundant predictors

step2a$collinear_PB  


#### Results for the api35 dataset -----

step2b$FG_test    # Significant result
step2b$collinear_PB




## ----tab4, eval = knitr::is_html_output(), layout = "l-body-outset"-----------
#> dat4 = rbind(c("Same type predictors"     , "NO" , "FALSE", "Allowed"),
#>              c("Same type predictors"     , "YES", "TRUE" , "Not allowed"),
#>              c("Different type predictors", "NO" , "FALSE", "Allowed"),
#>              c("Different type predictors", "YES", "TRUE" , "Not allowed")
#>              )
#> 
#> dat4 = as.data.frame(dat4)
#> colnames(dat4) = c("Possible scenarios", "Correlation between predictors",
#>                    "State of the RF_condi argument", "Incomplete information")
#> 
#> kable(dat4, 'html', booktabs =TRUE,
#>       caption = "Completing the `RF_condi` argument according to predictors",
#>       align = "cccc", escape = FALSE) %>%
#>   kableExtra::kable_styling(position = "center") %>%
#>   column_spec(1, width = "12em") %>%
#>   column_spec(2, width = "9em") %>%
#>   column_spec(3, width = "9em") %>%
#>   column_spec(4, width = "10em")


## ----code8, echo = TRUE, eval = TRUE------------------------------------------
step2a$RF_PRED   # For the api29 dataset


step2b$RF_PRED   # For the api35 dataset




## ----code9, echo = TRUE, eval = TRUE------------------------------------------
bdd_ex = step1$DB_READY[, c(1:3,10:12)]; head(bdd_ex,3)




## ----tab5, eval = knitr::is_html_output(), layout = "l-body-outset"-----------
#> dat5 = rbind(c("`datab`"       , "X", "X", "Data.frame in the expected structure"),
#>              c("`index_DB_Y_Z`", "X", "X", "Indexes of the `ID`, `Y`, and `Z` columns (1,2,3)"),
#>              c("`nominal`"     , "X", "X", "Column indexes of nominal variables (*)"),
#>              c("`ordinal`"     , "X", "X", "Column indexes of ordinal variables (*)"),
#>              c("`logic`"       , "X", "X", "Column indexes of boolean variables (*)"),
#>              c("`quanti`"      , "X", "X", "Column indexes of quantitative variables (*)"),
#>              c("`convert.num`" , "X", "X", "Column indexes of the quantitative variables to convert (* or `=quanti` in `OT_joint`)"),
#>              c("`convert.clss`", "X", "X", "Corresponding numbers of desired classes for conversion (*)"),
#>              c("`which.DB`"    , "X", "X", "Specify the target variables to complete: both or only one (BOTH)"),
#>              c("`solvR`"       , "X", "X", "Choice of the solver to solve the optimization problem (glpk)"),
#>              c("`dist.choice`" , "X", "X", "Distance function (Euclidean). See Table 7"),
#>              c("`percent.knn`" , "X", "X", "Ratio of closest neighbors involved in the computations (1)"),
#>              c("`indiv.method`", "X", "" , "Type of individual predictions (sequential) for `OUTCOME` and `R-OUTCOME` algorithms"),
#>              c("`maxrelax`"    , "X", "X", "Adding of a relaxation parameter (0)"),
#>              c("`lambda.reg`"  , "" , "X", "Adding of regularization parameter (0)")
#>              )
#> 
#> #for(i in 1:nrow(dat5)) {
#> #  dat5[i, 1] <- kableExtra::cell_spec(dat5[i, 1], "html", italic = TRUE, color = "darkgray")
#> #}
#> 
#> dat5 = as.data.frame(dat5)
#> colnames(dat5) = c("Argument", "`OT_outcome`", "`OT_joint`", "Description (default value)")
#> 
#> kable(dat5, 'html', booktabs =TRUE,
#>       caption = "Main arguments of the `OT_outcome` and `OT_joint` functions. (*: NULL as default value)",
#>       align = "lccl", escape = FALSE) %>%
#>   kableExtra::kable_styling(position = "center") %>%
#>   column_spec(1, width = "5em") %>%
#>   column_spec(2, width = "6em") %>%
#>   column_spec(3, width = "6em") %>%
#>   column_spec(4, width = "20em")


## ----tab6, eval = knitr::is_html_output(), layout = "l-body-outset"-----------
#> dat6 = rbind(c("`time_exe`"     , "X", "X", "Running time of the algorithm"),
#>              c("`gamma_A`"      , "X", "X", "Estimation of the joint distribution of (Y, Z) for the prediction of Z in A (*)"),
#>              c("`gamma_B`"      , "X", "X", "Estimation of the joint distribution of (Y, Z) for the prediction of Y in B (*)"),
#>              c("`profile`"      , "X", "X", "The list of detected profiles of covariates"),
#>              c("`res.prox`"     , "X", "X", "A list that provides all the information related to the estimated proximities between profiles and groups of profiles"),
#>              c("`estimator_ZA`" , "X", "X", "Estimates of the probability distribution of Z conditional to X and Y in database A (*)"),
#>              c("`estimator_YB`" , "X", "X", "Estimates of the probability distribution of Y conditional to X and Z in database B (*)"),
#>              c("`DATA1_OT`"     , "X", "X", "The database A fully completed (if required in input by the `which.DB` argument)"),
#>              c("`DATA2_OT`"     , "X", "X", "The database B fully completed (if required in input by the `which.DB` argument)")
#> )
#> 
#> dat6 = as.data.frame(dat6)
#> colnames(dat6) = c("Value", "`OT_outcome`", "`OT_joint`", "Description")
#> 
#> kable(dat6, 'html', booktabs =TRUE,
#>       caption = "Values of the `OT_outcome` and `OT_joint` functions. (*: NULL if not required)",
#>       align = "lccl", escape = FALSE) %>%
#>   kableExtra::kable_styling(position = "center") %>%
#>   column_spec(1, width = "5em") %>%
#>   column_spec(2, width = "6em") %>%
#>   column_spec(3, width = "6em") %>%
#>   column_spec(4, width = "20em")


## ----tab7, eval = knitr::is_html_output(), layout = "l-body-outset"-----------
#> dat7 = rbind(c("Continuous"            , "Standardized" , "Standardized" , "No"      , "Not allowed"),
#>              c("Boolean"               , "Binary"       , "Binary"       , "No"      , "Binary"),
#>              c("Nominal"               , "Disjunctive T", "Disjunctive T", "No"      , "Disjunctive T"),
#>              c("Ordinal"               , "Discrete"     , "Discrete"     , "No"      , "Disjunctive T"),
#>              c("Incomlete information" , "Allowed*"     , "Allowed*"     , "Allowed*", "Allowed*"),
#>              c("`dist.choice` argument", "`E`"          , "`M`"          , "`G`"     , "`H`")
#>              )
#> 
#> colnames(dat7) = c("Variable transformations", "Euclidean", "Manhattan", "Gower", "Hamming")
#> 
#> kable(dat7, 'html', booktabs =TRUE,
#>       caption = "Internal variable transformations related to the choice of each distance function in `OT_outcome` and `OT_joint` . (*) If the number of covariates exceeds 1. T for table",
#>       align = "lcccc", escape = FALSE) %>%
#>   kableExtra::kable_styling(position = "center") %>%
#>   column_spec(1, width = "10em") %>%
#>   column_spec(2, width = "7em") %>%
#>   column_spec(3, width = "7em") %>%
#>   column_spec(4, width = "7em") %>%
#>   column_spec(5, width = "7em") %>%
#>   add_header_above(c(" " = 1, "Distance function" = 4), bold = TRUE) %>%
#>   row_spec(5, extra_css = "border-bottom: 1px solid") %>%
#>   row_spec(6, extra_css = "border-bottom: 1px solid")
#> 


## ----code10, echo = TRUE, eval = TRUE-----------------------------------------
outc1 = OT_outcome(bdd_ex, quanti = 1, ordinal = 2:6, 
                   dist.choice = "E", indiv.method = "sequential", 
                   which.DB = "B")

#---------------------------------------
# OT PROCEDURE in progress ...
#---------------------------------------
# Type                     = OUTCOME
# Distance                 = Euclidean
# Percent closest knn      = 100%
# Relaxation parameter     = NO
# Relaxation value         = 0
# Individual pred process  = Sequential
# DB imputed               = B
#---------------------------------------



## ----code11, echo = TRUE, eval = TRUE-----------------------------------------
outc1$gamma_B


outc1$profile[1,]         # the first profile




## ----code12, echo = TRUE, eval = TRUE-----------------------------------------
outc1$estimatorYB[1,,]    # conditional probabilities (1st profile)



## ----code13, echo = TRUE, eval = TRUE-----------------------------------------
head(outc1$DATA2_OT,3)  # The 1st 3 rows only




## ----code14, echo = TRUE, eval = FALSE----------------------------------------
#> ### R-OUTCOME algorithm: optimal assignments + relaxation parameter = 0
#> R_outc3 = OT_outcome(bdd_ex, quanti = 1, ordinal = 2:6,
#>                      dist.choice = "E" , indiv.method = "optimal",
#>                      which.DB = "B")
#> 


## ----code15, echo = TRUE, eval = FALSE----------------------------------------
#> ### R-OUTCOME algorithm: optimal assignments + relaxation parameter = 0.4
#> R_outc4 = OT_outcome(bdd_ex, quanti = 1, ordinal = 2:6,
#>                      dist.choice = "E",
#>                      indiv.method = "optimal",
#>                      maxrelax = 0.4, which.DB = "B")
#> 


## ----code16, echo = TRUE, eval = TRUE-----------------------------------------
outj1 = OT_joint(bdd_ex, nominal = 1, ordinal = c(2:6), 
                 dist.choice = "E"  , which.DB = "B")

#---------------------------------------
# OT JOINT PROCEDURE in progress ...
#---------------------------------------
# Type                  = JOINT
# Distance              = Euclidean
# Percent closest       = 100%
# Relaxation term       = 0
# Regularization term   = 0
# Aggregation tol cov   = 0.3
# DB imputed            = B
#---------------------------------------


### Extract individual predictions from the OTpred column
head(outj1$DATA2_OT,3)  # The 1st 3 rows only



## ----code17, echo = TRUE, eval = FALSE----------------------------------------
#> ### R-JOINT algorithm (relaxation parameter = 0.4)
#> R_outj1 = OT_joint(bdd_ex, nominal = 1, ordinal = c(2:6),
#>                    dist.choice = "E",  maxrelax = 0.4,
#>                    which.DB = "B")
#> 
#> ### R-JOINT algorithm (relaxation parameter = 0.4,
#> ###                                   & regularization parameter = 0.1)
#> R_outj4 = OT_joint(bdd_ex, nominal = 1, ordinal = c(2:6),
#>                    dist.choice = "E",  maxrelax = 0.4,
#>                    lambda.reg = 0.1,
#>                    which.DB = "B")
#> 


## ----code18, echo = TRUE, eval = TRUE-----------------------------------------
### Quality criteria for outc1 (OUTCOME model)
verif_outc1   = verif_OT(outc1, group.class = TRUE, ordinal = FALSE, 
                         stab.prob = TRUE, min.neigb = 5)

### First results related to outc1:
verif_outc1$nb.profil


verif_outc1$res.prox




## ----code19, echo = TRUE, eval = TRUE-----------------------------------------
verif_outc1$conf.mat


verif_outc1$res.grp




## ----code20, echo = TRUE, eval = TRUE-----------------------------------------
verif_outc1$hell




## ----code21, echo = TRUE, eval = TRUE-----------------------------------------
verif_outc1$eff.neig


verif_outc1$res.stab




## ----tab8, eval = knitr::is_html_output(), layout = "l-body-outset"-----------
#> dat8 = rbind(
#> 
#> 
#>   c("`outc1`"  , "`OUTCOME`"  , "`SEQUENTIAL`", "0.0", "`-`", "362", "0.86", "0.892"),
#>   c("`R_outc1`", "`R-OUTCOME`", "`SEQUENTIAL`", "0.4", "`-`", "362", "0.94", "0.923"),
#>   c("`R_outc2`", "`R-OUTCOME`", "`SEQUENTIAL`", "0.6", "`-`", "362", "0.91", "0.917"),
#>   c("`R_outc3`", "`R-OUTCOME`", "`OPTIMAL`"   , "0.0", "`-`", "362", "0.87", "0.911"),
#>   c("`R_outc4`", "`R-OUTCOME`", "`OPTIMAL`"   , "0.4", "`-`", "362", "0.95", "0.939"),
#>   c("`R_outc5`", "`R-OUTCOME`", "`OPTIMAL`"   , "0.6", "`-`", "362", "0.92", "0.932"),
#>   c("`outj1`"  , "`JOINT`"    , "`-`"         , "0.0", "0.0", "362", "0.74", "0.834"),
#>   c("`R_outj1`", "`R-JOINT`"  , "`-`"         , "0.4", "0.0", "362", "0.95", "0.935"),
#>   c("`R_outj2`", "`R-JOINT`"  , "`-`"         , "0.6", "0.0", "362", "0.91", "0.927"),
#>   c("`R_outj3`", "`R-JOINT`"  , "`-`"         , "0.8", "0.0", "362", "0.91", "0.927"),
#>   c("`R_outj4`", "`R-JOINT`"  , "`-`"         , "0.4", "0.1", "362", "0.95", "0.931")
#> 
#> )
#> 
#> colnames(dat8) = c("Model", "Type", "Method", "Relax", "Regul", "N", "V_cram", "rank_cor")
#> 
#> kable(dat8, 'html', booktabs =TRUE,
#>       caption = "V Cramer criterion (`V_cram`) and rank correlation (`rank_cor`) between `apicl_1999` (the observed variable) and `apicl_2000` (the predicted variable) in the `api35` database `(N=362)`. Predictions comes from 11 models with various algorithms, relaxation and regularization parameters. They are very stable and reproductible here when the relaxation parameter differs from 0.",
#>   align = "llcccccc", escape = FALSE) %>%
#>   kableExtra::kable_styling(position = "center") %>%
#>   column_spec(1, width = "5em") %>%
#>   row_spec(6, extra_css = "border-bottom: 1px solid")
#> #  column_spec(1, width = "7em", border_right = T)
#> 


## ----tab9, eval = knitr::is_html_output(), layout = "l-body-outset"-----------
#> dat9 = rbind(
#> 
#> 
#>   c("`outc1`"  , "`OUTCOME`"  , "`SEQUENTIAL`", "0.0", "0.008"),
#>   c("`R_outc1`", "`R-OUTCOME`", "`SEQUENTIAL`", "0.4", "0.085"),
#>   c("`R_outc2`", "`R-OUTCOME`", "`SEQUENTIAL`", "0.6", "0.107"),
#>   c("`R_outc3`", "`R-OUTCOME`", "`OPTIMAL`"   , "0.0", "0.002"),
#>   c("`R_outc4`", "`R-OUTCOME`", "`OPTIMAL`"   , "0.4", "0.080"),
#>   c("`R_outc5`", "`R-OUTCOME`", "`OPTIMAL`"   , "0.6", "0.102")
#> 
#> )
#> 
#> 
#> colnames(dat9) = c("Model", "Type", "Method", "Relax", "Hell(YA_YB)")
#> 
#> kable(dat9, 'html', booktabs =TRUE,
#>       caption = "Hellinger distances related to the 6 models that used `OUTCOME` and `R-OUTCOME` algorithms. The values are relatively homogeneous from one model to another and do not indicate strong ditributional divergences (all values are very far from 1). Nevertheless, choosing here relaxation parameters higher than 0.4 can increase the risk of distributional dissimilarities (indeed, the criterion moves away from 0.05 when the relaxation parameter increases).",
#>       align = "llccc", escape = FALSE) %>%
#>   kableExtra::kable_styling(position = "center") %>%
#>   column_spec(1, width = "5em")
#> 


## ----tab10, eval = knitr::is_html_output(), layout = "l-body-outset"----------
#> dat10 = rbind(
#> 
#> 
#>   c("`outc1`"  , "`OUTCOME`"  , "`SEQUENTIAL`", "0.0", "`-`", "284", "0.968", "0.122"),
#>   c("`R_outc1`", "`R-OUTCOME`", "`SEQUENTIAL`", "0.4", "`-`", "284", "0.950", "0.151"),
#>   c("`R_outc2`", "`R-OUTCOME`", "`SEQUENTIAL`", "0.6", "`-`", "284", "0.954", "0.145"),
#>   c("`R_outc3`", "`R-OUTCOME`", "`OPTIMAL`"   , "0.0", "`-`", "284", "0.979", "0.100"),
#>   c("`R_outc4`", "`R-OUTCOME`", "`OPTIMAL`"   , "0.4", "`-`", "284", "0.987", "0.080"),
#>   c("`R_outc5`", "`R-OUTCOME`", "`OPTIMAL`"   , "0.6", "`-`", "284", "0.983", "0.091"),
#>   c("`outj1`"  , "`JOINT`"    , "`-`"         , "0.0", "0.0", "284", "0.911", "0.116"),
#>   c("`R_outj1`", "`R-JOINT`"  , "`-`"         , "0.4", "0.0", "284", "0.942", "0.128"),
#>   c("`R_outj2`", "`R-JOINT`"  , "`-`"         , "0.6", "0.0", "284", "0.953", "0.171"),
#>   c("`R_outj3`", "`R-JOINT`"  , "`-`"         , "0.8", "0.0", "284", "0.934", "0.199"),
#>   c("`R_outj4`", "`R-JOINT`"  , "`-`"         , "0.4", "0.1", "284", "0.926", "0.097")
#> 
#> )
#> 
#> colnames(dat10) = c("Model", "Type", "Method", "Relax", "Regul", "N", "mean", "sd")
#> 
#> kable(dat10, 'html', booktabs =TRUE,
#>       caption = "Stability of the predictions `(min.neigb = 5)`. When the `R_outj1` model will be confronted with a same profile of predictors and a same level of `apicl_1999`, more than 94 times of a hundred (`mean = 0.942`), it will be able to return the same individual prediction for `apicl_2000`. Among the `OUTCOME` family of algorithms, `R_outc4` provides here the best stability of prediction while `R_outj2` is the optimal one in the `JOINT` family of algorithms.",
#>       align = "llcccccc", escape = FALSE) %>%
#>   kableExtra::kable_styling(position = "center") %>%
#>   column_spec(1, width = "5em") %>%
#>   row_spec(6, extra_css = "border-bottom: 1px solid")
#> #  column_spec(1, width = "7em", border_right = T)
#> 


## ----tab11, eval = knitr::is_html_output(), layout = "l-body-outset"----------
#> dat11 = rbind(
#> 
#>   c("`R_outc1`"  , "0.84", rep("`-`", 4)),
#>   c("`R_outc4`"  , "0.83", "0.95", rep("`-`", 3)),
#>   c("`outj1`"    , "0.72", "0.81", "0.83", rep("`-`", 2)),
#>   c("`R_outj1`"  , "0.83", "0.91", "0.94", "0.84", rep("`-`", 1)),
#>   c("`R_outj4`"  , "0.84", "0.96", "0.97", "0.84", "0.92")
#> 
#> )
#> 
#> colnames(dat11) = c("Model", "`outc1`", "`R_outc1`", "`R_outc4`", "`outj1`", "`R_outj1`")
#> 
#> 
#> for(i in 1:nrow(dat11)) {
#>   dat11[i, 1] <- kableExtra::cell_spec(dat11[i, 1], "html", bold = TRUE)
#> }
#> 
#> 
#> 
#> kable(dat11, 'html', booktabs =TRUE,
#>       caption = "Ratio of common predictions between two models",
#>       align = "lccccc", escape = FALSE) %>%
#>   kableExtra::kable_styling(position = "center") %>%
#>   column_spec(1, width = "5em")
#> #  column_spec(1, width = "7em", border_right = T)
#> 


## ----tab12, eval = knitr::is_html_output(), layout = "l-body-outset"----------
#> dat12 = rbind(
#>   rep("", 11),
#>   c("[200-600]" , "91", "15", "0" , "0" , "", "[200-600]" , "91", "14", "1", "0"),
#>   c("[600-800]" , "0", "75" , "90", "0" , "", "[600-800]" , "0", "76" , "89", "0"),
#>   c("[800-1000]", "0", "0"  , "0" , "91", "", "[800-1000]", "0", "0"  , "0", "91"),
#>   rep("", 11)
#> )
#> 
#> colnames(dat12) = c("apicl_2000", "G1", "G2", "G3", "G4", "", "apicl_2000","G1", "G2", "G3", "G4")
#> 
#> kable(dat12, 'html', booktabs =TRUE,
#>       caption = "Confusion matrices in the `api35` dataset for the models (a) `R_outc4` and (b) `R_outj1`",
#>       align = "ccccccccccc", escape = FALSE) %>%
#>   kableExtra::kable_styling(position = "center") %>%
#>   add_header_above(c("(a)" = 1, "apicl_1999" = 4, " " = 1, "(b)" = 1, "apicl_1999" = 4), bold = TRUE) %>%
#>   column_spec(1, width = "7em") %>%
#>   column_spec(6, width = "4em") %>%
#>   column_spec(7, width = "7em")
#> 


## ----supplementary, echo = TRUE, eval = FALSE---------------------------------
#> ### BASIC R CODE FOR SUMMARY TABLES  8, 9, 10, and 11 ---------
#> 
#> ## Validation of each model: Repeat the following R command for each model by
#> ## changing outc1:
#> verif_outc1   = verif_OT(outc1, group.class = TRUE, ordinal = FALSE,
#>                          stab.prob = TRUE, min.neigb = 5)
#> 
#> ## Association between Y and Z: Summary Table 8
#> res.prx = rbind(
#>            outc1   = verif_outc1$res.prox    , R_outc1 = verif_R_outc1$res.prox,
#>            R_outc2 = verif_R_outc2$res.prox  , R_outc3 = verif_R_outc3$res.prox,
#>            R_outc4 = verif_R_outc4$res.prox  , R_outc5 = verif_R_outc5$res.prox,
#>            outj1   = verif_outj1$res.prox    , R_outj1 = verif_R_outj1$res.prox,
#>            R_outj2 = verif_R_outj2$res.prox  , R_outj3 = verif_R_outj3$res.prox,
#>            R_outj4 = verif_R_outj4$res.prox )
#> 
#> res.prx = data.frame(Model = c("outc1","R_outc2","R_outc3","R_outc4",
#>                                "R_outc5","R_outc6","outj1", "R_outj1",
#>                                "R_outj2","R_outj3","R_outj4"),
#>                      Type  = c("OUTCOME",rep("R-OUTCOME",5),"JOINT",
#>                                rep("R-JOINT",4)),
#>                      Relax = c(0,0.4,0.6,0,0.4,0.6,0,0.4,0.6,0.8,0.4),
#>                      Regul = c(rep(0,10),0.1), res.prx)
#> 
#> row.names(res.prx) = NULL; head(res.prx,3)
#> 
#> #    Name      Type Relax Regul   N V_cram rank_cor
#> #   outc1   OUTCOME   0.0   0.0 362   0.86    0.892
#> # R_outc1 R-OUTCOME   0.0   0.0 362   0.87    0.911
#> # R_outc2 R_OUTCOME   0.4   0.0 362   0.93    0.933
#> #-----
#> 
#> ## Hellinger distance: Summary Table 9
#> res.helld = rbind(
#>              outc1   = verif_outc1$hell  , R_outc1 = verif_R_outc1$hell,
#>              R_outc2 = verif_R_outc2$hell, R_outc3 = verif_R_outc3$hell,
#>              R_outc4 = verif_R_outc4$hell, R_outc5 = verif_R_outc5$hell,
#>              outj1   = verif_outj1$hell  , R_outj1 = verif_R_outj1$hell,
#>              R_outj2 = verif_R_outj2$hell, R_outj3 = verif_R_outj3$hell,
#>              R_outj4 = verif_R_outj4$hell )
#> 
#> res.helld = data.frame(res.prx[,1:4], res.helld)
#> row.names(res.helld) = NULL; res.helld
#> #-----
#> 
#> ## Stability of the prediction: Summary Table 10
#> # same R code as for Summary Table 8, changing res.prox by res.stab
#> #----
#> 
#> ## Ratio of common predictions: Table 11
#> 
#> stoc = list(outc1$DATA2_OT$OTpred  , R_outc1$DATA2_OT$OTpred,
#>             R_outc4$DATA2_OT$OTpred, outj1$DATA2_OT$OTpred  ,
#>             R_outj1$DATA2_OT$OTpred, R_outj4$DATA2_OT$OTpred)
#> 
#> corpred = matrix(ncol = 6, nrow = 6)
#> for (i in 1:6){
#>       for (j in 1:6){
#>         corpred[i,j] = round(sum(diag(table(stoc[[i]],stoc[[j]])))/362,2)
#>       }
#> }; corpred
#> #-----

