# Generated by `rjournal_pdf_article()` using `knitr::purl()`: do not edit by hand
# Please edit RJ-2023-015.Rmd to modify this file

## ----setup, include=FALSE-----------------------------------------------------
library(lmeresampler)
library(HLMdiag)
library(lme4)
library(nlme)


## ----eval=FALSE---------------------------------------------------------------
#> bootstrap(model, .f, type, B, resample = NULL, reb_type = NULL, hccme, aux.dist,
#>           orig_data, .refit)


## ----boots, eval = knitr::is_html_output(), echo=FALSE------------------------
#> tibble::tribble(
#>   ~Bootstrap,  ~`Function name`, ~`Required arguments`,
#>   "Cases",       "`case_bootstrap`",        "`model, .f, type, B, resample, orig_data, .refit`",
#>     "Residual",    "`resid_bootstrap`",    "`model, .f, type, B, orig_data, .refit`",
#>     "REB",         "`reb_bootstrap`",        "`model, .f, type, B, reb_type, orig_data, .refit`",
#>     "Wild",        "`wild_bootstrap`",        "`model, .f, type, B, hccme, aux.dist, orig_data, .refit`",
#>     "Parametric",  "`parametric_bootstrap`",  "`model, .f, type, B, orig_data, .refit`"
#> ) |>
#>   knitr::kable(format = "html", caption = "Summary of the specific bootstrap functions called by `bootstrap()` and their required arguments.")


## ----return, eval = knitr::is_html_output(), echo=FALSE-----------------------
#> tibble::tribble(
#>   ~Element,   ~Description,
#>   "`observed`", "values for the original model parameter estimates.",
#>   "`model`",       "the original fitted model object." ,
#>   "`.f`",          "the function call defining the parameters of interest.",
#>   "`replicates`",  "a $B \\times p$ tibble containing the bootstrapped quantities. Each column contains a single bootstrap distribution.",
#>   "`stats`",        "a tibble containing the `observed`, `rep.mean` (bootstrap mean), `se` (bootstrap standard error), and `bias` values for each parameter.",
#>   "`B`",           "the number of bootstrap resamples performed.",
#>   "`data`",        "the original data set.",
#>   "`seed`",        "a vector of randomly generated seeds that are used by the bootstrap.",
#>   "`type`",        "a character string specifying the type of bootstrap performed.",
#>   "`call`",        "the user's call to the bootstrap function.",
#> "`message`",     "a list of length `B` giving any messages generated during refitting. An entry will be `NULL` if no message was generated.",
#> "`warning`",     "a list of length `B` giving any warnings generated during refitting. An entry will be `NULL` if no warning was generated.",
#> "`error`",       "a list of length `B` giving any errors encountered during refitting. An entry will be `NULL` if no error was encountered."
#> ) |>
#>   knitr::kable(format = "html", caption = "Summary of the specific bootstrap functions called by `bootstrap()` and their required arguments.")


## -----------------------------------------------------------------------------
library(lmeresampler)
tibble::as_tibble(jsp728)


## ----message=FALSE------------------------------------------------------------
library(lme4)
jsp_mod <- lmer(mathAge11 ~ mathAge8 + gender + class + (1 | school), data = jsp728)


## ----cache=TRUE---------------------------------------------------------------
(jsp_boot <- bootstrap(jsp_mod, .f = fixef, type = "residual", B = 2000))


## -----------------------------------------------------------------------------
confint(jsp_boot)


## -----------------------------------------------------------------------------
data("BeetlesBody", package = "rptR")
(beetle_mod <- lmer(BodyL ~ (1 | Population), data = BeetlesBody))


## -----------------------------------------------------------------------------
repeatability <- function(object) {
  vc <- as.data.frame(VarCorr(object))
  vc$vcov[1] / (sum(vc$vcov))
}


## -----------------------------------------------------------------------------
repeatability(beetle_mod)


## ----cache=TRUE---------------------------------------------------------------
(beetle_boot <- bootstrap(beetle_mod, .f = repeatability, type = "parametric", B = 2000))
(beetle_ci <- confint(beetle_boot, type = "basic"))


## ----density, fig.cap="Density plot of the repeatabilities from the beetle model. The median bootstrap repeatability is approximatley .28 and denoted by a point under the density.  66\\% and 95\\% confidence intervals for the bootstrap repeatability are (0.217, 0.394) and (0.118, 0.475), respectively, and are displayed as line segments below the density.", fig.alt = "The figure is a density plot displaying the bootstrap distribution of the repeatability. Repeatability is displayed on the x-axis and density is displayed on the y-axis. A point marks the median repeatability on the x-axis, with the 66% and 95% bootstrap percentile intervals marked using lines.", fig.height = 2.25, fig.width = 3, fig.align='center', out.width = "40%"----
plot(beetle_boot, .width = c(.5, .9)) + 
  ggplot2::labs(
    title = "Bootstrap repeatabilities",
    y = "density",
    x = "repeatability"
  )


## -----------------------------------------------------------------------------
summary(jsp_mod)$coefficients


## ----cache=TRUE---------------------------------------------------------------
reduced_model <- update(jsp_mod, . ~ . - class)
reduced_boot <- bootstrap(reduced_model, type = "wild", B = 1000, hccme = "hc2", 
                          aux.dist = "mammen", .refit = FALSE)


## ----cache=TRUE---------------------------------------------------------------
extract_t <- function(model, term) {
  coef(summary(model))[term, "t value"]
}

tstats <- purrr::map_dbl(
  reduced_boot, 
  ~refit(jsp_mod, .x) %>% extract_t(., term = "classnonmanual")
)


## -----------------------------------------------------------------------------
(sum(abs(tstats) >= extract_t(jsp_mod)) + 1) / (1000 + 1)


## ----cache=TRUE---------------------------------------------------------------
bootstrap_pvals(jsp_mod, type = "wild", B = 1000, hccme = "hc2", aux.dist = "mammen")


## -----------------------------------------------------------------------------
data("Machines", package = "nlme")


## -----------------------------------------------------------------------------
reduced_mod <- lmer(score ~ Machine + (1 | Worker), data = Machines, REML = FALSE)


## -----------------------------------------------------------------------------
full_mod <- lmer(score ~ Machine + (1 | Worker/Machine), data = Machines, REML = FALSE)


## ----cache=TRUE---------------------------------------------------------------
observed <- anova(full_mod, reduced_mod)$Chisq[2]

reduced_boot <- bootstrap(reduced_mod, type = "residual", B = 1000, .refit = FALSE)


## ----cache=TRUE---------------------------------------------------------------
compare_models <- function(full, reduced, newdata) {
  full_mod <- refit(full, newdata, 
                    control = lmerControl(check.conv.singular = "ignore", 
                                          check.conv.grad = "ignore"))
  reduced_mod <- refit(reduced, newdata)
  anova(full_mod, reduced_mod)$Chisq[2]
}
 
chisq_stats <- purrr::map_dbl(reduced_boot, ~compare_models(full_mod, reduced_mod, newdata = .x))


## -----------------------------------------------------------------------------
(sum(chisq_stats >= observed) + 1) / (1000 + 1)


## -----------------------------------------------------------------------------
library(nlme)
dialyzer_mod <- lme(
  rate ~ (pressure + I(pressure^2) + I(pressure^3) + I(pressure^4)) * QB, 
  data = Dialyzer, 
  random = ~ pressure + I(pressure^2)
)


## ----residdialyzer, echo = FALSE, fig.cap="A plot of the conditional residuals against the transmembrane pressure for the dialyzer model. It appears that the variability of the conditional residuals increases with transmembrance pressure, but does this indicate a model condition is violated?", fig.alt = "A plot of the residuals on the y-axis and the transmembrane pressure on the x-axis. A line is draw at y = 0 and the spread of the points around this line is increasing with transmembrane pressure.", fig.height = 2.5, fig.width = 3, fig.align='center', out.width="40%"----
library(ggplot2)
ggplot(Dialyzer, aes(x = pressure, y = resid(dialyzer_mod))) +
  geom_hline(yintercept = 0, color = "gray60") +
  geom_point(shape = 1) +
  theme_bw() +
  labs(x = "Transmembrane pressure (dmHg)", y = "Residuals (ml/hr)")


## ----cache=TRUE---------------------------------------------------------------
set.seed(1234)
library(HLMdiag)
sim_resids <- bootstrap(dialyzer_mod, .f = hlm_resid, type = "parametric", B = 19)


## -----------------------------------------------------------------------------
dplyr::glimpse(sim_resids$replicates)


## -----------------------------------------------------------------------------
library(nullabor)
lineup_data <- lineup(true = hlm_resid(dialyzer_mod), n = 19, samples = sim_resids$replicates)
dplyr::glimpse(lineup_data)


## ----lineup, fig.cap="A lineup of the conditional residuals against the transmembrane pressure for the dialyzer model. One of the facets contains the true residual plot generated from the fitted model, the others are decoys generated using a parametric bootstrap. Facet 13 contains the observed residuals and is discernibly different from decoy plots, providing evidence of that a model condition has been violated.", fig.alt = "A lineup plot comprised of 20 facets that all display plots of the conditional residuals on the y-axis and transmembrance pressure on the x-axis. The facets are numbered 1 to 20. Nineteen of the plots display simulated residuals, which show little structure. Facet 13 displays the observed data, which shows increasing spread of the residuals.", fig.height = 6.875, fig.height = 6, fig.align='center'----
ggplot(lineup_data, aes(x = pressure, y = .resid)) +
  geom_hline(yintercept = 0, color = "gray60") +
  geom_point(shape = 1) +
  facet_wrap(~.sample) +
  theme_bw() +
  labs(x = "Transmembrane pressure (dmHg)", y = "Residuals (ml/hr)")


## ----cache=TRUE---------------------------------------------------------------
wild_dialyzer <- bootstrap(dialyzer_mod, .f = fixef, type = "wild", B = 1000, 
                           hccme = "hc2", aux.dist = "webb")

confint(wild_dialyzer, type = "perc")


## ----include=FALSE, eval=FALSE------------------------------------------------
#> library(foreach)
#> library(doParallel)
#> nboot <- rep(1000, 2)
#> 
#> set.seed(5678)
#> 
#> # Starting a cluster with 2 cores
#> no_cores <- 2
#> cl <- makeCluster(no_cores)
#> registerDoParallel(cores = no_cores)
#> 
#> # Run 1000 bootstrap iterations on each core
#> ptime <- system.time({
#>   boot_parallel <- foreach(
#>     B = nboot,
#>     .combine = combine_lmeresamp,
#>     .packages = c("lmeresampler", "lme4")
#>   ) %dopar% {
#>     bootstrap(jsp_mod, .f = fixef, type = "parametric", B = B)
#>   }
#> })
#> 
#> # Stop the cluster
#> stopCluster(cl)
#> 
#> stime <- system.time({
#>   boot_parallel <- foreach(
#>     B = nboot,
#>     .combine = combine_lmeresamp,
#>     .packages = c("lmeresampler", "lme4")
#>   ) %do% {
#>     bootstrap(jsp_mod, .f = fixef, type = "parametric", B = B)
#>   }
#> })


## ----cache=TRUE---------------------------------------------------------------
library(foreach)
library(doParallel)

set.seed(5678)

# Starting a cluster with 2 cores
no_cores <- 2
cl <- makeCluster(no_cores)
registerDoParallel(cores = no_cores)

# Run 1000 bootstrap iterations on each core
boot_parallel <- foreach(
  B = rep(1000, 2), 
  .combine = combine_lmeresamp,
  .packages = c("lmeresampler", "lme4")
) %dopar% {
  bootstrap(jsp_mod, .f = fixef, type = "parametric", B = B)
}

# Stop the cluster
stopCluster(cl)


## ----echo=FALSE---------------------------------------------------------------
stime <- readr::read_rds("serial_time.RDS")
stime


## ----echo=FALSE---------------------------------------------------------------
ptime <- readr::read_rds("parallel_time.RDS")
ptime

